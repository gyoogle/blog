(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{383:function(t,v,_){"use strict";_.r(v);var a=_(27),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"동적-계획법-dynamic-programming"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#동적-계획법-dynamic-programming"}},[t._v("#")]),t._v(" 동적 계획법(Dynamic Programming)")]),t._v(" "),_("hr"),t._v(" "),_("br"),t._v(" "),_("blockquote",[_("p",[t._v("복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법")])]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("흔히 말하는 DP가 바로 '동적 계획법'")]),t._v(" "),_("p",[_("strong",[t._v("한 가지 문제")]),t._v("에 대해서, "),_("strong",[t._v("단 한 번만 풀도록")]),t._v(" 만들어주는 알고리즘이다.")]),t._v(" "),_("p",[t._v("즉, 똑같은 연산을 반복하지 않도록 만들어준다. 실행 시간을 줄이기 위해 많이 이용되는 수학적 접근 방식의 알고리즘이라고 할 수 있다.")]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("동적 계획법은 "),_("strong",[t._v("Optimal Substructure")]),t._v("에서 효과를 발휘한다.")]),t._v(" "),_("p",[_("em",[t._v("Optimal Substructure")]),t._v(" : 답을 구하기 위해 이미 했던 똑같은 계산을 계속 반복하는 문제 구조")]),t._v(" "),_("br"),t._v(" "),_("h3",{attrs:{id:"접근-방식"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#접근-방식"}},[t._v("#")]),t._v(" 접근 방식")]),t._v(" "),_("p",[t._v("커다란 문제를 쉽게 해결하기 위해 작게 쪼개서 해결하는 방법인 분할 정복과 매우 유사하다. 하지만 간단한 문제로 만드는 과정에서 중복 여부에 대한 차이점이 존재한다.")]),t._v(" "),_("p",[t._v("즉, 동적 계획법은 간단한 작은 문제들 속에서 '계속 반복되는 연산'을 활용하여 빠르게 풀 수 있는 것이 핵심이다.")]),t._v(" "),_("br"),t._v(" "),_("h3",{attrs:{id:"조건"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#조건"}},[t._v("#")]),t._v(" 조건")]),t._v(" "),_("ul",[_("li",[t._v("작은 문제에서 반복이 일어남")]),t._v(" "),_("li",[t._v("같은 문제는 항상 정답이 같음")])]),t._v(" "),_("p",[t._v("이 두 가지 조건이 충족한다면, 동적 계획법을 이용하여 문제를 풀 수 있다.")]),t._v(" "),_("p",[t._v("같은 문제가 항상 정답이 같고, 반복적으로 일어난다는 점을 활용해 메모이제이션(Memoization)으로 큰 문제를 해결해나가는 것이다.")]),t._v(" "),_("br"),t._v(" "),_("p",[_("em",[t._v("메모이제이션(Memoization)")]),t._v(" : 한 번 계산한 문제는 다시 계산하지 않도록 저장해두고 활용하는 방식")]),t._v(" "),_("blockquote",[_("p",[t._v("피보나치 수열에서 재귀를 활용하여 풀 경우, 같은 연산을 계속 반복함을 알 수 있다.")]),t._v(" "),_("p",[t._v("이때, 메모이제이션을 통해 같은 작업을 되풀이 하지 않도록 구현하면 효율적이다.")])]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("fibonacci(5) = fibonacci(4) + fibonacci(3)\nfibonacci(4) = fibonacci(3) + fibonacci(2)\nfibonacci(3) = fibonacci(2) + fibonacci(1)\n\n이처럼 같은 연산이 계속 반복적으로 이용될 때, 메모이제이션을 활용하여 값을 미리 저장해두면 효율적\n")])])]),_("p",[t._v("피보나치 구현에 재귀를 활용했다면 시간복잡도는 O(2^n)이지만, 동적 계획법을 활용하면 O(N)으로 해결할 수 있다.")]),t._v(" "),_("br"),t._v(" "),_("h3",{attrs:{id:"구현-방식"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#구현-방식"}},[t._v("#")]),t._v(" 구현 방식")]),t._v(" "),_("ul",[_("li",[t._v("Bottom-up : 작은 문제부터 차근차근 구하는 방법")]),t._v(" "),_("li",[t._v("Top-down : 큰 문제를 풀다가 풀리지 않은 작은 문제가 있다면 그때 해결하는 방법 (재귀 방식)")])]),t._v(" "),_("blockquote",[_("p",[t._v("Bottom-up은 해결이 용이하지만, 가독성이 떨어짐")]),t._v(" "),_("p",[t._v("Top-down은 가독성이 좋지만, 코드 작성이 힘듬")])]),t._v(" "),_("br"),t._v(" "),_("p",[t._v("동적 계획법으로 문제를 풀 때는, 우선 작은 문제부터 해결해나가보는 것이 좋다.")]),t._v(" "),_("p",[t._v("작은 문제들을 풀어나가다보면 이전에 구해둔 더 작은 문제들이 활용되는 것을 확인하게 된다. 이에 대한 규칙을 찾았을 때 "),_("strong",[t._v("점화식")]),t._v("을 도출해내어 동적 계획법을 적용시키자")]),t._v(" "),_("br"),t._v(" "),_("br"),t._v(" "),_("h4",{attrs:{id:"참고-자료"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#참고-자료"}},[t._v("#")]),t._v(" [참고 자료]")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95",target:"_blank",rel:"noopener noreferrer"}},[t._v("링크"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=r.exports}}]);