(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{335:function(t,a,e){"use strict";e.r(a);var r=e(19),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"웹"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#웹"}},[t._v("#")]),t._v(" 웹")]),t._v(" "),e("hr"),t._v(" "),e("br"),t._v(" "),e("h2",{attrs:{id:"스프링"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#스프링"}},[t._v("#")]),t._v(" 스프링")]),t._v(" "),e("br"),t._v(" "),e("h4",{attrs:{id:"dispatcher-servlet"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dispatcher-servlet"}},[t._v("#")]),t._v(" Dispatcher-Servlet")]),t._v(" "),e("p",[t._v("서블릿 컨테이너에서 HTTP 프로토콜을 통해 들어오는 모든 요청을 제일 앞에서 처리해주는 프론트 컨트롤러를 말함")]),t._v(" "),e("p",[t._v("따라서 서버가 받기 전에, 공통처리 작업을 디스패처 서블릿이 처리해주고 적절한 세부 컨트롤러로 작업을 위임해줍니다.")]),t._v(" "),e("p",[t._v("디스패처 서블릿이 처리하는 url 패턴을 지정해줘야 하는데, 일반적으로는 .mvc와 같은 패턴으로 처리하라고 미리 지정해줍니다.")]),t._v(" "),e("p",[t._v("디스패처 서블릿으로 인해 web.xml이 가진 역할이 상당히 축소되었습니다. 기존에는 모든 서블릿을 url 매핑 활용을 위해 모두 web.xml에 등록해 주었지만, 디스패처 서블릿은 그 전에 모든 요청을 핸들링해주면서 작업을 편리하게 할 수 있도록 도와줍니다. 또한 이 서블릿을 통해 MVC를 사용할 수 있기 때문에 웹 개발 시 큰 장점을 가져다 줍니다.")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"di-dependency-injection"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#di-dependency-injection"}},[t._v("#")]),t._v(" DI(Dependency Injection)")]),t._v(" "),e("p",[t._v("스프링 컨테이너가 지원하는 핵심 개념 중 하나로, 설정 파일을 통해 객체간의 의존관계를 설정하는 역할을 합니다.")]),t._v(" "),e("p",[t._v("각 클래스 사이에 필요로 하는 의존관계를 Bean 설정 정보 바탕으로 컨테이너가 자동으로 연결합니다.")]),t._v(" "),e("p",[t._v("객체는 직접 의존하고 있는 객체를 생성하거나 검색할 필요가 없으므로 코드 관리가 쉬워지는 장점이 있습니다.")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"aop-aspect-oriented-programming"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop-aspect-oriented-programming"}},[t._v("#")]),t._v(" AOP(Aspect Oriented Programming)")]),t._v(" "),e("p",[t._v("공통의 관심 사항을 적용해서 발생하는 의존 관계의 복잡성과 코드 중복을 해소해줍니다.")]),t._v(" "),e("p",[t._v("각 클래스에서 공통 관심 사항을 구현한 모듈에 대한 의존관계를 갖기 보단, Aspect를 이용해 핵심 로직을 구현한 각 클래스에 공통 기능을 적용합니다.")]),t._v(" "),e("p",[t._v("간단한 설정만으로도 공통 기능을 여러 클래스에 적용할 수 있는 장점이 있으며 핵심 로직 코드를 수정하지 않고도 웹 애플리케이션의 보안, 로깅, 트랜잭션과 같은 공통 관심 사항을 AOP를 이용해 간단하게 적용할 수 있습니다.")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"aop-용어"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop-용어"}},[t._v("#")]),t._v(" AOP 용어")]),t._v(" "),e("p",[t._v("Advice : 언제 공통 관심기능을 핵심 로직에 적용할지 정의")]),t._v(" "),e("p",[t._v("Joinpoint : Advice를 적용이 가능한 지점을 의미 (before, after 등등)")]),t._v(" "),e("p",[t._v("Pointcut : Joinpoint의 부분집합으로, 실제로 Advice가 적용되는 Joinpoint를 나타냄")]),t._v(" "),e("p",[t._v("Weaving : Advice를 핵심 로직코드에 적용하는 것")]),t._v(" "),e("p",[t._v("Aspect : 여러 객체에 공통으로 적용되는 공통 관심 사항을 말함. 트랜잭션이나 보안 등이 Aspect의 좋은 예")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"dao-data-access-object"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dao-data-access-object"}},[t._v("#")]),t._v(" DAO(Data Access Object)")]),t._v(" "),e("p",[t._v("DB에 데이터를 조회하거나 조작하는 기능들을 전담합니다.")]),t._v(" "),e("p",[t._v("Mybatis를 이용할 때는, mapper.xml에 쿼리문을 작성하고 이를 mapper 클래스에서 받아와 DAO에게 넘겨주는 식으로 구현합니다.")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"annotation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#annotation"}},[t._v("#")]),t._v(" Annotation")]),t._v(" "),e("p",[t._v("소스코드에 @어노테이션의 형태로 표현하며 클래스, 필드, 메소드의 선언부에 적용할 수 있는 특정기능이 부여된 표현법을 말합니다.")]),t._v(" "),e("p",[t._v("애플리케이션 규모가 커질수록, xml 환경설정이 매우 복잡해지는데 이러한 어려움을 개선시키기 위해 자바 파일에 어노테이션을 적용해서 개발자가 설정 파일 작업을 할 때 발생시키는 오류를 최소화해주는 역할을 합니다.")]),t._v(" "),e("p",[t._v("어노테이션 사용으로 소스 코드에 메타데이터를 보관할 수 있고, 컴파일 타임의 체크뿐 아니라 어노테이션 API를 사용해 코드 가독성도 높여줍니다.")]),t._v(" "),e("ul",[e("li",[t._v("@Controller : dispatcher-servlet.xml에서 bean 태그로 정의하는 것과 같음.")]),t._v(" "),e("li",[t._v("@RequestMapping : 특정 메소드에서 요청되는 URL과 매칭시키는 어노테이션")]),t._v(" "),e("li",[t._v("@Autowired : 자동으로 의존성 주입하기 위한 어노테이션")]),t._v(" "),e("li",[t._v("@Service : 비즈니스 로직 처리하는 서비스 클래스에 등록")]),t._v(" "),e("li",[t._v("@Repository : DAO에 등록")])]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"spring-jdbc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-jdbc"}},[t._v("#")]),t._v(" Spring JDBC")]),t._v(" "),e("p",[t._v("데이터베이스 테이블과, 자바 객체 사이의 단순한 매핑을 간단한 설정을 통해 처리하는 것")]),t._v(" "),e("p",[t._v("기존의 JDBC에서는 구현하고 싶은 로직마다 필요한 SQL문이 모두 달랐고, 이에 필요한 Connection, PrepareStatement, ResultSet 등을 생성하고 Exception 처리도 모두 해야하는 번거러움이 존재했습니다.")]),t._v(" "),e("p",[t._v("Spring에서는 JDBC와 ORM 프레임워크를 직접 지원하기 때문에 따로 작성하지 않아도 모두 다 처리해주는 장점이 있습니다.")]),t._v(" "),e("p",[e("br"),e("br")]),t._v(" "),e("h4",{attrs:{id:"mybatis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[t._v("#")]),t._v(" MyBatis")]),t._v(" "),e("p",[t._v("객체, 데이터베이스, Mapper 자체를 독립적으로 작성하고, DTO에 해당하는 부분과 SQL 실행결과를 매핑해서 사용할 수 있도록 지원함")]),t._v(" "),e("p",[t._v("기존에는 DAO에 모두 SQL문이 자바 소스상에 위치했으나, MyBatis를 통해 SQL은 XML 설정 파일로 관리합니다.")]),t._v(" "),e("p",[t._v("설정파일로 분리하면, 수정할 때 설정파일만 건드리면 되므로 유지보수에 매우 좋습니다. 또한 매개변수나 리턴 타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업할 수 있는 장점이 있습니다.")]),t._v(" "),e("p",[e("br"),e("br")])])}),[],!1,null,null,null);a.default=v.exports}}]);