(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{305:function(t,s,a){"use strict";a.r(s);var n=a(12),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"최소-공통-조상-lowest-common-ancestor-알고리즘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#최소-공통-조상-lowest-common-ancestor-알고리즘"}},[t._v("#")]),t._v(" 최소 공통 조상(Lowest Common Ancestor) 알고리즘")]),t._v(" "),s("hr"),t._v(" "),s("br"),t._v(" "),s("blockquote",[s("p",[t._v("최소 공통 조상 찾는 알고리즘")]),t._v(" "),s("p",[t._v("→ 두 정점이 만나는 최초 부모 정점을 찾는 것!")])]),t._v(" "),s("p",[t._v("트리 형식이 아래와 같이 주어졌다고 하자")]),t._v(" "),s("img",{attrs:{src:"https://media.geeksforgeeks.org/wp-content/cdn-uploads/lca.png",width:"400"}}),t._v(" "),s("p",[t._v("4와 5의 LCA는? → 4와 5의 첫 부모 정점은 '2'")]),t._v(" "),s("p",[t._v("4와 6의 LCA는? → 첫 부모 정점은 root인 '1'")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("어떻게 찾죠?")])])]),t._v(" "),s("p",[t._v("해당 정점의 depth와 parent를 저장해두는 방식이다. 현재 그림에서의 depth는 아래와 같을 것이다.")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("[depth : 정점]\n0 → 1(root 정점)\n1 → 2, 3\n2 → 4, 5, 6, 7\n")])])]),s("br"),t._v(" "),s("p",[t._v("parent는 정점마다 가지는 부모 정점을 저장해둔다. 위의 예시에서 저장된 parent 배열은 아래와 같다.")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1 ~ 7번 정점 (root는 부모가 없기 때문에 0)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" parent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("이제")]),t._v(" "),s("p",[t._v("이 두 배열을 활용해서 두 정점이 주어졌을 때 LCA를 찾을 수 있다. 과정은 아래와 같다.")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 두 정점의 depth 확인하기")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("depth가 일치"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("두 정점의 parent 일치"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" LCA 찾음"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("종료"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" 두 정점을 자신의 parent 정점 값으로 변경\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// depth 불일치")]),t._v("\n        더 depth가 깊은 정점을 해당 정점의 parent 정점으로 변경"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("depth가 감소됨"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("br"),t._v(" "),s("p",[t._v("트리 문제에서 공통 조상을 찾아야하는 문제나, 정점과 정점 사이의 이동거리 또는 방문경로를 저장해야 할 경우 사용하면 된다.")])])}),[],!1,null,null,null);s.default=e.exports}}]);