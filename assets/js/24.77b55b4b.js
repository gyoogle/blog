(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{403:function(t,a,s){"use strict";s.r(a);var n=s(27),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"퀵-정렬-quick-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#퀵-정렬-quick-sort"}},[t._v("#")]),t._v(" 퀵 정렬(Quick Sort)")]),t._v(" "),s("hr"),t._v(" "),s("h3",{attrs:{id:"goal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#goal"}},[t._v("#")]),t._v(" Goal")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("Quick Sort에 대해 설명할 수 있다.")]),t._v(" "),s("li",[t._v("Quick Sort 과정에 대해 설명할 수 있다.")]),t._v(" "),s("li",[t._v("Quick Sort을 구현할 수 있다.")]),t._v(" "),s("li",[t._v("Quick Sort의 시간복잡도와 공간복잡도를 계산할 수 있다.")]),t._v(" "),s("li",[t._v("Quick Sort의 최악인 경우를 개선시킬 수 있다.")])]),t._v(" "),s("h3",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[t._v("#")]),t._v(" Abstract")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("Quick Sort은 "),s("strong",[t._v("분할 정복(divide and conquer) 방법")]),t._v(" 을 통해 주어진 배열을 정렬한다.")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("* [분할 정복(divide and conquer) 방법]\n문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략이다.\n")])])]),s("p",[t._v("Quick Sort은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 또한 Merge Sort와 달리 Quick Sort는 배열을 비균등하게 분할한다.")]),t._v(" "),s("h3",{attrs:{id:"process-ascending"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#process-ascending"}},[t._v("#")]),t._v(" Process (Ascending)")]),t._v(" "),s("hr"),t._v(" "),s("ol",[s("li",[t._v("배열 가운데서 하나의 원소를 고른다. 이렇게 고른 원소를 "),s("strong",[t._v("피벗(pivot)")]),t._v(" 이라고 한다.")]),t._v(" "),s("li",[t._v("피벗 앞에는 피벗보다 값이 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 값이 큰 모든 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다. 이렇게 배열을 둘로 나누는 것을 "),s("strong",[t._v("분할(Divide)")]),t._v(" 이라고 한다. 분할을 마친 뒤에 피벗은 더 이상 움직이지 않는다.")]),t._v(" "),s("li",[t._v("분할된 두 개의 작은 배열에 대해 재귀(Recursion)적으로 이 과정을 반복한다.")])]),t._v(" "),s("ul",[s("li",[t._v("재귀 호출이 한번 진행될 때마다 최소한 하나의 원소는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.")])]),t._v(" "),s("h3",{attrs:{id:"java-code-ascending"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-code-ascending"}},[t._v("#")]),t._v(" Java Code (Ascending)")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("퀵 정렬은 다음의 단계들로 이루어진다.")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("정복 (Conquer)")]),t._v(" "),s("p",[t._v("부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출을 이용하여 다시 분할 정복 방법을 적용한다.")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 분할 ")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pivot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("partition")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n    \n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 피벗은 제외한 2개의 부분 배열을 대상으로 순환 호출")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 정복(Conquer)")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("quickSort")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pivot"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 정복(Conquer)")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("분할 (Divide)")]),t._v(" "),s("p",[t._v("입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열 "),s("strong",[t._v("(피벗을 중심으로 왼쪽 : 피벗보다 작은 요소들, 오른쪽 : 피벗보다 큰 요소들)")]),t._v(" 로 분할한다.")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("partition")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n    // 최악의 경우, 개선 방법\n    int mid = (left + right) / 2;\n    swap(array, left, mid);\n    */")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" pivot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 가장 왼쪽값을 피벗으로 설정")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pivot "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" pivot "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("swap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    array"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" pivot"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"quick-sort-개선"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#quick-sort-개선"}},[t._v("#")]),t._v(" Quick Sort 개선")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("partition() 함수에서 "),s("strong",[t._v("피벗 값이 최소나 최대값으로 지정되어 파티션이 나누어지지 않았을 때,")]),t._v(" O(n^2)에 대한 시간복잡도를 가진다.")]),t._v(" "),s("p",[t._v("즉, 정렬하고자 하는 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있으면 O(n^2)의 시간복잡도를 가진다. 이때, 배열에서 가장 앞에 있는 값과 중간값을 교환해준다면 확률적으로나마 시간복잡도 O(nlog₂n)으로 개선할 수 있다. 하지만, 이 방법으로 개선한다해도 "),s("code",[t._v("Quick Sort의 최악의 시간복잡도가 O(nlog₂n)가 되는 것은 아니다.")])]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"gif로-이해하는-quick-sort"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gif로-이해하는-quick-sort"}},[t._v("#")]),t._v(" GIF로 이해하는 Quick Sort")]),t._v(" "),s("hr"),t._v(" "),s("p",[s("a",{attrs:{href:"https://github.com/GimunLee/tech-refrigerator/blob/master/Algorithm/resources/quick-sort-001.gif",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-001.gif",alt:"img"}}),s("OutboundLink")],1)]),t._v(" "),s("br"),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"시간복잡도"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#시간복잡도"}},[t._v("#")]),t._v(" 시간복잡도")]),t._v(" "),s("hr"),t._v(" "),s("h4",{attrs:{id:"최선의-경우-best-cases-t-n-o-nlog2n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#최선의-경우-best-cases-t-n-o-nlog2n"}},[t._v("#")]),t._v(" 최선의 경우(Best cases) : T(n) = O(nlog₂n)")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("비교 횟수 "),s("code",[t._v("(log₂n)")])]),t._v(" "),s("p",[t._v("레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k) 했을 때, n=2^3의 경우, 2^3 -> 2^2 -> 2^1 -> 2^0 순으로 줄어들어 순환 호출의 깊이가 3임을 알 수 있다.")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-002.png",alt:"img"}})]),t._v(" "),s("p",[t._v("이것을 일반화하면 n=2^k의 경우, "),s("strong",[t._v("k(k=log₂n)")]),t._v(" 임을 알 수 있다.")])]),t._v(" "),s("li",[s("p",[t._v("각 순환 호출 단계의 비교 연산 "),s("code",[t._v("(n)")])]),t._v(" "),s("p",[t._v("각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 "),s("strong",[t._v("평균 n번")]),t._v(" 정도의 비교가 이루어진다.")])])]),t._v(" "),s("p",[t._v("따라서, 최선의 시간복잡도는 "),s("code",[t._v("순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = nlog₂n")]),t._v(" 가 된다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.")]),t._v(" "),s("br"),t._v(" "),s("h4",{attrs:{id:"최악의-경우-worst-cases-t-n-o-n-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#최악의-경우-worst-cases-t-n-o-n-2"}},[t._v("#")]),t._v(" 최악의 경우(Worst cases) : T(n) = O(n^2)")]),t._v(" "),s("p",[t._v("최악의 경우는 정렬하고자 하는 배열이 오름차순 정렬되어있거나 내림차순 정렬되어있는 경우다.")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("비교 횟수 "),s("code",[t._v("(n)")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://github.com/GimunLee/tech-refrigerator/raw/master/Algorithm/resources/quick-sort-003.png",alt:"img"}})]),t._v(" "),s("p",[t._v("레코드의 개수 n이 2의 거듭제곱이라고 가정(n=2^k)했을 때, 순환 호출의 깊이는 "),s("strong",[t._v("n")]),t._v(" 임을 알 수 있다.")])]),t._v(" "),s("li",[s("p",[t._v("각 순환 호출 단계의 비교 연산 "),s("code",[t._v("(n)")])]),t._v(" "),s("p",[t._v("각 순환 호출에서는 전체 리스트의 대부분의 레코드를 비교해야 하므로 **평균 n번 ** 정도의 비교가 이루어진다.")])])]),t._v(" "),s("p",[t._v("따라서, 최악의 시간복잡도는 "),s("code",[t._v("순환 호출의 깊이 * 각 순환 호출 단계의 비교 연산 = n^2")]),t._v(" 다. 이동 횟수는 비교 횟수보다 적으므로 무시할 수 있다.")]),t._v(" "),s("br"),t._v(" "),s("h4",{attrs:{id:"평균의-경우-average-cases-t-n-o-nlog2n"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#평균의-경우-average-cases-t-n-o-nlog2n"}},[t._v("#")]),t._v(" 평균의 경우(Average cases) : T(n) = O(nlog₂n)")]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"공간복잡도"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#공간복잡도"}},[t._v("#")]),t._v(" 공간복잡도")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("주어진 배열 안에서 교환(swap)을 통해, 정렬이 수행되므로 **O(n)**이다.")]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"장점"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#장점"}},[t._v("#")]),t._v(" 장점")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[t._v("불필요한 데이터의 이동을 줄이고 먼 거리의 데이터를 교환할 뿐만 아니라, 한 번 결정된 피벗들이 추후 연산에서 제외되는 특성 때문에, 시간 복잡도가 O(nlog₂n)를 가지는 다른 정렬 알고리즘과 비교했을 때도 가장 빠르다.")]),t._v(" "),s("li",[t._v("정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다.")])]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"단점"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#단점"}},[t._v("#")]),t._v(" 단점")]),t._v(" "),s("hr"),t._v(" "),s("ul",[s("li",[s("strong",[t._v("불안정 정렬(Unstable Sort)")]),t._v(" 이다.")]),t._v(" "),s("li",[t._v("정렬된 배열에 대해서는 Quick Sort의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다.")])]),t._v(" "),s("br"),t._v(" "),s("h3",{attrs:{id:"conclusion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[t._v("#")]),t._v(" Conclusion")]),t._v(" "),s("hr"),t._v(" "),s("p",[t._v("평균적으로 가장 빠른 정렬 알고리즘에 대해서 알아봤다. JAVA에서 Arrays.sort() 내부적으로도 Dual Pivot Quick Sort로 구현되어 있을 정도로 효율적인 알고리즘이고, "),s("code",[t._v("기술 면접에서 정말 빈번하게 나오는 주제이므로 반드시 숙지하자")])]),t._v(" "),s("br"),t._v(" "),s("h4",{attrs:{id:"참고-자료"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#참고-자료"}},[t._v("#")]),t._v(" [참고 자료]")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://jinhyy.tistory.com/9",target:"_blank",rel:"noopener noreferrer"}},[t._v("링크"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);