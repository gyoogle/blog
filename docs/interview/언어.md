# 언어

---

<br><br>

#### 가비지 컬렉션이란?

 정리되지 않은 메모리, 유효하지 않은 메모리 주소인 가비지를 정리해주는 프로그램

 Heap 메모리를 재활용 하기위해 참조되지 않는 객체들을 해제시켜 가용한 공간을 만드는 작업

 프로그래머가 직접 메모리를 정리하지 않아도 되어 개발 속도가 대폭 향상된다.

 메모리를 언제 되찾을 지 결정하기 위한 오버헤드 발생 문제점 존재

<br><br>

#### Vector와 ArrayList의 차이는?

 Vector : 동기식. 한 스레드가 벡터 작업 중이면 다른 스레드가 벡터 보유 불가능

 ArrayList : 비동기식. 여러 스레드가 arraylist에서 동시 작업이 가능

<br><br>

#### String과 StringBuffer의 차이는?

 String : 불변. 문자를 수정하려면 지우고 다시 생성해야함 (new) → 문자열 연산이 많으면 기능 떨어짐

 StringBuffer : 가변. 한번 만들고 필요할 때 크기를 변경하여 문자를 변경함 (append()와 같이)

 StringBuilder : 동기화 지원X. 멀티스레드 환경에 부적합 → 싱글 스레드에서 StringBuffer보다 좋음

<br><br>

#### Serialization이란?

 직렬화. 객체의 상태 혹은 데이터 구조를 기록할 수 있는 포맷으로 변환해줌

 나중에 재구성 할 수 있게 자바 객체를 JSON으로 변환해주거나 JSON을 자바 객체로 변환해주는 라이브러리

<br><br>

#### Java의 메모리 영역은?

 - 메소드 / 스택 / 힙

 메소드 : 바이트 코드, 전역 변수, static 변수

 스택 : 매개 변수, 지역 변수 (사용 끝나면 바로 소멸, 컴파일 시에 메모리 할당)

 힙 : new로 생성된 객체(c에서는 malloc()). 호출이 끝나도 사라지지 않고 프로그램 실행 시 동적 할당

<br><br>

#### 오버로딩과 오버라이딩 차이는?

 오버로딩 : 메소드의 이름은 같고, 매개변수를 다르게 함으로써 여러 메소드를 만드는 것

 오버라이딩 : 부모클래스로부터 상속받은 메소드를 재정의하는 것. 자식 객체에서 오버라이딩한 메소드는 호출시 오버라이딩한 메소드가 우선시 되어 호출됨 (동일한 리턴타입, 메소드 이름, 매개변수를 가져야함)

<br><br>

#### 추상클래스와 인터페이스 차이는?

 추상클래스 : 클래스 내에 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우. extends를 통해 기능을 이용하고 확장하도록 하는 클래스

 인터페이스 : 모든 메소드가 추상 메소드인 경우 (여러 implements가 가능해 다중 상속 구현 가능)  뼈대만 있으며, 구현하는 모든 클래스에 대해 강제적으로 메소드를 구현하도록 만듬

<br><br>

#### 제네릭이란?

 클래스에서 사용할 타입을 클래스 외부에서 설정하도록 만드는 것

 제네릭으로 선언한 클래스는, 내가 원하는 타입으로 만들어 사용이 가능함

 <안에는 참조자료형(클래스, 인터페이스, 배열)만 가능함

 (기본자료형을 이용하기 위해선 wrapper 클래스를 활용해야 함)

<br><br>

#### 접근 지정자 4가지

 public : 모든 접근 허용

 protected : 상속받은 클래스 or 같은 패키지만 접근 허용

 default : 기본 제한자. 자신 클래스 내부 or 같은 패키지만 접근 허용

 private : 외부 접근 불가능. 같은 클래스 내에서만 가능

<br><br>

#### Call by Value vs Call by Reference

 값에 의한 호출 : 값을 복사해서 새로운 함수로 넘기는 호출 방식. 원본 값 변경X

 참조에 의한 호출 :  주소 값을 인자로 전달하는 호출 방식. 원본 값 변경O

<br><br>

#### 배열과 연결리스트 차이는?

 배열은 인덱스를 가짐. 원하는 데이터를 한번에 접근하기 때문에 접근 속도 빠름.

 크기 변경이 불가능하며, 데이터 삽입 및 삭제 시 그 위치의 다음 위치부터 모든 데이터 위치를 변경해야 되는 단점 존재

 연결리스트는 인덱스 대신에 현재 위치의 이전/다음 위치를 기억함.

 크기는 가변적. 인덱스 접근이 아니기 때문에 연결되어 있는 링크를 쭉 따라가야 접근이 가능함. (따라서 배열보다 속도 느림)

 데이터 삽입 및 삭제는 논리적 주소만 바꿔주면 되기 때문에 매우 용이함

 - 데이터의 양이 많고 삽입/삭제가 없음. 데이터 검색을 많이 해야할 때 → Array
 - 데이터의 양이 적고 삽입/삭제 빈번함 → LinkedList

<br><br>

#### Hash란?

 데이터 삽입 및 삭제 시, 기존 데이터를 밀어내거나 채우지 않고 데이터와 연관된 고유한 숫자를 생성해 인덱스로 사용하는 방법

 검색 속도가 매우 빠르다

<br><br>

#### Java 컴파일 과정

 컴파일러가 소스코드를 자바 바이트 코드(.class)로 변환

 JVM이 바이트코드를 기계어로 변환하고, 인터프리터 방식으로 애플리케이션 실행

<br><br>

#### C++ 실행 과정

 - 전처리 : #define, #include 지시자 해석

 - 컴파일 : 고급 언어 소스 프로그램 입력 받고, 어셈블리 파일 만듬

 - 어셈블 : 어셈블리 파일을 오브젝트 파일로 만듬

 - 링크 : 오브젝트 파일을 엮어 실행파일을 만들고 라이브러리 함수 연결

 - 실행

<br><br>

#### 메모리, 성능을 개선하기 위해 생각나는 방법은?

 static을 사용해 선언한다.

 인스턴스 변수에 접근할 일이 없으면, static 메소드를 선언하여 호출하자

 모든 객체가 서로 공유할 수 있기 때문에 메모리가 절약되고 연속적으로 그 값의 흐름을 이어갈 수 있는 장점이 존재

<br><br>

#### 클래스와 구조체의 차이는?

 구조체는 하나의 구조로 묶일 수 있는 변수들의 집합이다.

 클래스는 변수뿐만 아니라, 메소드도 포함시킬 수 있음

 (물론 함수 포인터를 이용해 구조체도 클래스처럼 만들어 낼 수도 있다.)

<br><br>

#### 스레드는 어떤 방식으로 생성하나요? 장단점도 말해주세요

 생성방법 : Runnable(인터페이스)로 선언되어 있는 클래스 or Thread 클래스를 상속받아서 run() 메소드를 구현해주면 됨

 장점 : 빠른 프로세스 생성, 메모리를 적게 사용 가능, 정보 공유가 쉬움

 단점 : 데드락에 빠질 위험이 존재

<br><br>

#### 포인터를 이해하기 쉽도록 설명해주세요

 포인터는 메모리 주소를 저장하는 변수임

 주소를 지칭하고 있는 곳인데, 예를 들면 엘리베이터에서 포인터는 해당 층을 표시하는 버튼이라고 할 수 있음. 10층을 누르면 10층으로 이동하듯, 해당 위치를 가리키고 있는 변수!

 포인터를 사용할 때 주의할 점은, 어떤 주소를 가리키고 있어야만 사용이 가능함

